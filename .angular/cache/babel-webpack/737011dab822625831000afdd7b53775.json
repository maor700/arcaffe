{"ast":null,"code":"/* @preserve\n* @terraformer/wkt - v2.0.6 - MIT\n* Copyright (c) 2012-2020 Environmental Systems Research Institute, Inc.\n* Mon May 18 2020 14:30:36 GMT-0700 (Pacific Daylight Time)\n*/\n\n/* global parser */\n// via jison\n\n/* Copyright (c) 2012-2020 Environmental Systems Research Institute, Inc.\n * MIT */\n\n/** @module Terraformer */\nvar o = function o(k, v, _o, l) {\n  for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}\n\n  return _o;\n},\n    $V0 = [1, 52],\n    $V1 = [1, 59],\n    $V2 = [1, 65],\n    $V3 = [1, 79],\n    $V4 = [1, 84],\n    $V5 = [14, 18],\n    $V6 = [1, 90],\n    $V7 = [1, 96],\n    $V8 = [1, 110];\n\nvar parser = {\n  trace: function trace() {},\n  yy: {},\n  symbols_: {\n    \"error\": 2,\n    \"expressions\": 3,\n    \"point\": 4,\n    \"EOF\": 5,\n    \"linestring\": 6,\n    \"polygon\": 7,\n    \"multipoint\": 8,\n    \"multilinestring\": 9,\n    \"multipolygon\": 10,\n    \"coordinate\": 11,\n    \"DOUBLE_TOK\": 12,\n    \"ptarray\": 13,\n    \"COMMA\": 14,\n    \"ring_list\": 15,\n    \"ring\": 16,\n    \"(\": 17,\n    \")\": 18,\n    \"POINT\": 19,\n    \"Z\": 20,\n    \"ZM\": 21,\n    \"M\": 22,\n    \"EMPTY\": 23,\n    \"point_untagged\": 24,\n    \"polygon_list\": 25,\n    \"polygon_untagged\": 26,\n    \"point_list\": 27,\n    \"LINESTRING\": 28,\n    \"POLYGON\": 29,\n    \"MULTIPOINT\": 30,\n    \"MULTILINESTRING\": 31,\n    \"MULTIPOLYGON\": 32,\n    \"$accept\": 0,\n    \"$end\": 1\n  },\n  terminals_: {\n    2: \"error\",\n    5: \"EOF\",\n    12: \"DOUBLE_TOK\",\n    14: \"COMMA\",\n    17: \"(\",\n    18: \")\",\n    19: \"POINT\",\n    20: \"Z\",\n    21: \"ZM\",\n    22: \"M\",\n    23: \"EMPTY\",\n    28: \"LINESTRING\",\n    29: \"POLYGON\",\n    30: \"MULTIPOINT\",\n    31: \"MULTILINESTRING\",\n    32: \"MULTIPOLYGON\"\n  },\n  productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [11, 2], [11, 3], [11, 4], [13, 3], [13, 1], [15, 3], [15, 1], [16, 3], [4, 4], [4, 5], [4, 5], [4, 5], [4, 2], [24, 1], [24, 3], [25, 3], [25, 1], [26, 3], [27, 3], [27, 1], [6, 4], [6, 5], [6, 5], [6, 5], [6, 2], [7, 4], [7, 5], [7, 5], [7, 5], [7, 2], [8, 4], [8, 5], [8, 5], [8, 5], [8, 2], [9, 4], [9, 5], [9, 5], [9, 5], [9, 2], [10, 4], [10, 5], [10, 5], [10, 5], [10, 2]],\n  performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate\n  /* action[1] */\n  , $\n  /* vstack */\n  , _$\n  /* lstack */\n  ) {\n    /* this == yyval */\n    var $0 = $.length - 1;\n\n    switch (yystate) {\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n        return $[$0 - 1];\n        break;\n\n      case 7:\n        this.$ = new PointArray([Number($[$0 - 1]), Number($[$0])]);\n        break;\n\n      case 8:\n        this.$ = new PointArray([Number($[$0 - 2]), Number($[$0 - 1]), Number($[$0])]);\n        break;\n\n      case 9:\n        this.$ = new PointArray([Number($[$0 - 3]), Number($[$0 - 2]), Number($[$0 - 1]), Number($[$0])]);\n        break;\n\n      case 10:\n      case 25:\n        this.$ = $[$0 - 2].addPoint($[$0]);\n        break;\n\n      case 11:\n      case 20:\n      case 26:\n        this.$ = $[$0];\n        break;\n\n      case 12:\n        this.$ = $[$0 - 2].addRing($[$0]);\n        break;\n\n      case 13:\n        this.$ = new RingList($[$0]);\n        break;\n\n      case 14:\n        this.$ = new Ring($[$0 - 1]);\n        break;\n\n      case 15:\n        this.$ = {\n          \"type\": \"Point\",\n          \"coordinates\": $[$0 - 1].data[0]\n        };\n        break;\n\n      case 16:\n        this.$ = {\n          \"type\": \"Point\",\n          \"coordinates\": $[$0 - 1].data[0],\n          \"properties\": {\n            z: true\n          }\n        };\n        break;\n\n      case 17:\n        this.$ = {\n          \"type\": \"Point\",\n          \"coordinates\": $[$0 - 1].data[0],\n          \"properties\": {\n            z: true,\n            m: true\n          }\n        };\n        break;\n\n      case 18:\n        this.$ = {\n          \"type\": \"Point\",\n          \"coordinates\": $[$0 - 1].data[0],\n          \"properties\": {\n            m: true\n          }\n        };\n        break;\n\n      case 19:\n        this.$ = {\n          \"type\": \"Point\",\n          \"coordinates\": []\n        };\n        break;\n\n      case 21:\n      case 24:\n        this.$ = $[$0 - 1];\n        break;\n\n      case 22:\n        this.$ = $[$0 - 2].addPolygon($[$0]);\n        break;\n\n      case 23:\n        this.$ = new PolygonList($[$0]);\n        break;\n\n      case 27:\n        this.$ = {\n          \"type\": \"LineString\",\n          \"coordinates\": $[$0 - 1].data\n        };\n        break;\n\n      case 28:\n        this.$ = {\n          \"type\": \"LineString\",\n          \"coordinates\": $[$0 - 1].data,\n          \"properties\": {\n            z: true\n          }\n        };\n        break;\n\n      case 29:\n        this.$ = {\n          \"type\": \"LineString\",\n          \"coordinates\": $[$0 - 1].data,\n          \"properties\": {\n            m: true\n          }\n        };\n        break;\n\n      case 30:\n        this.$ = {\n          \"type\": \"LineString\",\n          \"coordinates\": $[$0 - 1].data,\n          \"properties\": {\n            z: true,\n            m: true\n          }\n        };\n        break;\n\n      case 31:\n        this.$ = {\n          \"type\": \"LineString\",\n          \"coordinates\": []\n        };\n        break;\n\n      case 32:\n        this.$ = {\n          \"type\": \"Polygon\",\n          \"coordinates\": $[$0 - 1].toJSON()\n        };\n        break;\n\n      case 33:\n        this.$ = {\n          \"type\": \"Polygon\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            z: true\n          }\n        };\n        break;\n\n      case 34:\n        this.$ = {\n          \"type\": \"Polygon\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            m: true\n          }\n        };\n        break;\n\n      case 35:\n        this.$ = {\n          \"type\": \"Polygon\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            z: true,\n            m: true\n          }\n        };\n        break;\n\n      case 36:\n        this.$ = {\n          \"type\": \"Polygon\",\n          \"coordinates\": []\n        };\n        break;\n\n      case 37:\n        this.$ = {\n          \"type\": \"MultiPoint\",\n          \"coordinates\": $[$0 - 1].data\n        };\n        break;\n\n      case 38:\n        this.$ = {\n          \"type\": \"MultiPoint\",\n          \"coordinates\": $[$0 - 1].data,\n          \"properties\": {\n            z: true\n          }\n        };\n        break;\n\n      case 39:\n        this.$ = {\n          \"type\": \"MultiPoint\",\n          \"coordinates\": $[$0 - 1].data,\n          \"properties\": {\n            m: true\n          }\n        };\n        break;\n\n      case 40:\n        this.$ = {\n          \"type\": \"MultiPoint\",\n          \"coordinates\": $[$0 - 1].data,\n          \"properties\": {\n            z: true,\n            m: true\n          }\n        };\n        break;\n\n      case 41:\n        this.$ = {\n          \"type\": \"MultiPoint\",\n          \"coordinates\": []\n        };\n        break;\n\n      case 42:\n        this.$ = {\n          \"type\": \"MultiLineString\",\n          \"coordinates\": $[$0 - 1].toJSON()\n        };\n        break;\n\n      case 43:\n        this.$ = {\n          \"type\": \"MultiLineString\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            z: true\n          }\n        };\n        break;\n\n      case 44:\n        this.$ = {\n          \"type\": \"MultiLineString\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            m: true\n          }\n        };\n        break;\n\n      case 45:\n        this.$ = {\n          \"type\": \"MultiLineString\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            z: true,\n            m: true\n          }\n        };\n        break;\n\n      case 46:\n        this.$ = {\n          \"type\": \"MultiLineString\",\n          \"coordinates\": []\n        };\n        break;\n\n      case 47:\n        this.$ = {\n          \"type\": \"MultiPolygon\",\n          \"coordinates\": $[$0 - 1].toJSON()\n        };\n        break;\n\n      case 48:\n        this.$ = {\n          \"type\": \"MultiPolygon\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            z: true\n          }\n        };\n        break;\n\n      case 49:\n        this.$ = {\n          \"type\": \"MultiPolygon\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            m: true\n          }\n        };\n        break;\n\n      case 50:\n        this.$ = {\n          \"type\": \"MultiPolygon\",\n          \"coordinates\": $[$0 - 1].toJSON(),\n          \"properties\": {\n            z: true,\n            m: true\n          }\n        };\n        break;\n\n      case 51:\n        this.$ = {\n          \"type\": \"MultiPolygon\",\n          \"coordinates\": []\n        };\n        break;\n    }\n  },\n  table: [{\n    3: 1,\n    4: 2,\n    6: 3,\n    7: 4,\n    8: 5,\n    9: 6,\n    10: 7,\n    19: [1, 8],\n    28: [1, 9],\n    29: [1, 10],\n    30: [1, 11],\n    31: [1, 12],\n    32: [1, 13]\n  }, {\n    1: [3]\n  }, {\n    5: [1, 14]\n  }, {\n    5: [1, 15]\n  }, {\n    5: [1, 16]\n  }, {\n    5: [1, 17]\n  }, {\n    5: [1, 18]\n  }, {\n    5: [1, 19]\n  }, {\n    17: [1, 20],\n    20: [1, 21],\n    21: [1, 22],\n    22: [1, 23],\n    23: [1, 24]\n  }, {\n    17: [1, 25],\n    20: [1, 26],\n    21: [1, 28],\n    22: [1, 27],\n    23: [1, 29]\n  }, {\n    17: [1, 30],\n    20: [1, 31],\n    21: [1, 33],\n    22: [1, 32],\n    23: [1, 34]\n  }, {\n    17: [1, 35],\n    20: [1, 36],\n    21: [1, 38],\n    22: [1, 37],\n    23: [1, 39]\n  }, {\n    17: [1, 40],\n    20: [1, 41],\n    21: [1, 43],\n    22: [1, 42],\n    23: [1, 44]\n  }, {\n    17: [1, 45],\n    20: [1, 46],\n    21: [1, 48],\n    22: [1, 47],\n    23: [1, 49]\n  }, {\n    1: [2, 1]\n  }, {\n    1: [2, 2]\n  }, {\n    1: [2, 3]\n  }, {\n    1: [2, 4]\n  }, {\n    1: [2, 5]\n  }, {\n    1: [2, 6]\n  }, {\n    11: 51,\n    12: $V0,\n    13: 50\n  }, {\n    17: [1, 53]\n  }, {\n    17: [1, 54]\n  }, {\n    17: [1, 55]\n  }, {\n    5: [2, 19]\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 56\n  }, {\n    17: [1, 60]\n  }, {\n    17: [1, 61]\n  }, {\n    17: [1, 62]\n  }, {\n    5: [2, 31]\n  }, {\n    15: 63,\n    16: 64,\n    17: $V2\n  }, {\n    17: [1, 66]\n  }, {\n    17: [1, 67]\n  }, {\n    17: [1, 68]\n  }, {\n    5: [2, 36]\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 69\n  }, {\n    17: [1, 70]\n  }, {\n    17: [1, 71]\n  }, {\n    17: [1, 72]\n  }, {\n    5: [2, 41]\n  }, {\n    15: 73,\n    16: 64,\n    17: $V2\n  }, {\n    17: [1, 74]\n  }, {\n    17: [1, 75]\n  }, {\n    17: [1, 76]\n  }, {\n    5: [2, 46]\n  }, {\n    17: $V3,\n    25: 77,\n    26: 78\n  }, {\n    17: [1, 80]\n  }, {\n    17: [1, 81]\n  }, {\n    17: [1, 82]\n  }, {\n    5: [2, 51]\n  }, {\n    14: $V4,\n    18: [1, 83]\n  }, o($V5, [2, 11]), {\n    12: [1, 85]\n  }, {\n    11: 51,\n    12: $V0,\n    13: 86\n  }, {\n    11: 51,\n    12: $V0,\n    13: 87\n  }, {\n    11: 51,\n    12: $V0,\n    13: 88\n  }, {\n    14: $V6,\n    18: [1, 89]\n  }, o($V5, [2, 26]), o($V5, [2, 20]), {\n    11: 91,\n    12: $V0\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 92\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 93\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 94\n  }, {\n    14: $V7,\n    18: [1, 95]\n  }, o($V5, [2, 13]), {\n    11: 51,\n    12: $V0,\n    13: 97\n  }, {\n    15: 98,\n    16: 64,\n    17: $V2\n  }, {\n    15: 99,\n    16: 64,\n    17: $V2\n  }, {\n    15: 100,\n    16: 64,\n    17: $V2\n  }, {\n    14: $V6,\n    18: [1, 101]\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 102\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 103\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 57,\n    27: 104\n  }, {\n    14: $V7,\n    18: [1, 105]\n  }, {\n    15: 106,\n    16: 64,\n    17: $V2\n  }, {\n    15: 107,\n    16: 64,\n    17: $V2\n  }, {\n    15: 108,\n    16: 64,\n    17: $V2\n  }, {\n    14: $V8,\n    18: [1, 109]\n  }, o($V5, [2, 23]), {\n    15: 111,\n    16: 64,\n    17: $V2\n  }, {\n    17: $V3,\n    25: 112,\n    26: 78\n  }, {\n    17: $V3,\n    25: 113,\n    26: 78\n  }, {\n    17: $V3,\n    25: 114,\n    26: 78\n  }, {\n    5: [2, 15]\n  }, {\n    11: 115,\n    12: $V0\n  }, o($V5, [2, 7], {\n    12: [1, 116]\n  }), {\n    14: $V4,\n    18: [1, 117]\n  }, {\n    14: $V4,\n    18: [1, 118]\n  }, {\n    14: $V4,\n    18: [1, 119]\n  }, {\n    5: [2, 27]\n  }, {\n    11: 58,\n    12: $V0,\n    17: $V1,\n    24: 120\n  }, {\n    18: [1, 121]\n  }, {\n    14: $V6,\n    18: [1, 122]\n  }, {\n    14: $V6,\n    18: [1, 123]\n  }, {\n    14: $V6,\n    18: [1, 124]\n  }, {\n    5: [2, 32]\n  }, {\n    16: 125,\n    17: $V2\n  }, {\n    14: $V4,\n    18: [1, 126]\n  }, {\n    14: $V7,\n    18: [1, 127]\n  }, {\n    14: $V7,\n    18: [1, 128]\n  }, {\n    14: $V7,\n    18: [1, 129]\n  }, {\n    5: [2, 37]\n  }, {\n    14: $V6,\n    18: [1, 130]\n  }, {\n    14: $V6,\n    18: [1, 131]\n  }, {\n    14: $V6,\n    18: [1, 132]\n  }, {\n    5: [2, 42]\n  }, {\n    14: $V7,\n    18: [1, 133]\n  }, {\n    14: $V7,\n    18: [1, 134]\n  }, {\n    14: $V7,\n    18: [1, 135]\n  }, {\n    5: [2, 47]\n  }, {\n    17: $V3,\n    26: 136\n  }, {\n    14: $V7,\n    18: [1, 137]\n  }, {\n    14: $V8,\n    18: [1, 138]\n  }, {\n    14: $V8,\n    18: [1, 139]\n  }, {\n    14: $V8,\n    18: [1, 140]\n  }, o($V5, [2, 10]), o($V5, [2, 8], {\n    12: [1, 141]\n  }), {\n    5: [2, 16]\n  }, {\n    5: [2, 17]\n  }, {\n    5: [2, 18]\n  }, o($V5, [2, 25]), o($V5, [2, 21]), {\n    5: [2, 28]\n  }, {\n    5: [2, 29]\n  }, {\n    5: [2, 30]\n  }, o($V5, [2, 12]), o($V5, [2, 14]), {\n    5: [2, 33]\n  }, {\n    5: [2, 34]\n  }, {\n    5: [2, 35]\n  }, {\n    5: [2, 38]\n  }, {\n    5: [2, 39]\n  }, {\n    5: [2, 40]\n  }, {\n    5: [2, 43]\n  }, {\n    5: [2, 44]\n  }, {\n    5: [2, 45]\n  }, o($V5, [2, 22]), o($V5, [2, 24]), {\n    5: [2, 48]\n  }, {\n    5: [2, 49]\n  }, {\n    5: [2, 50]\n  }, o($V5, [2, 9])],\n  defaultActions: {\n    14: [2, 1],\n    15: [2, 2],\n    16: [2, 3],\n    17: [2, 4],\n    18: [2, 5],\n    19: [2, 6],\n    24: [2, 19],\n    29: [2, 31],\n    34: [2, 36],\n    39: [2, 41],\n    44: [2, 46],\n    49: [2, 51],\n    83: [2, 15],\n    89: [2, 27],\n    95: [2, 32],\n    101: [2, 37],\n    105: [2, 42],\n    109: [2, 47],\n    117: [2, 16],\n    118: [2, 17],\n    119: [2, 18],\n    122: [2, 28],\n    123: [2, 29],\n    124: [2, 30],\n    127: [2, 33],\n    128: [2, 34],\n    129: [2, 35],\n    130: [2, 38],\n    131: [2, 39],\n    132: [2, 40],\n    133: [2, 43],\n    134: [2, 44],\n    135: [2, 45],\n    138: [2, 48],\n    139: [2, 49],\n    140: [2, 50]\n  },\n  parseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n      this.trace(str);\n    } else {\n      var error = new Error(str);\n      error.hash = hash;\n      throw error;\n    }\n  },\n  parse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null],\n        lstack = [],\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        TERROR = 2,\n        EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = {\n      yy: {}\n    };\n\n    for (var k in this.yy) {\n      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n        sharedState.yy[k] = this.yy[k];\n      }\n    }\n\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n\n    if (typeof lexer.yylloc == 'undefined') {\n      lexer.yylloc = {};\n    }\n\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n\n    if (typeof sharedState.yy.parseError === 'function') {\n      this.parseError = sharedState.yy.parseError;\n    } else {\n      this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n\n    _token_stack: var lex = function lex() {\n      var token;\n      token = lexer.lex() || EOF;\n\n      if (typeof token !== 'number') {\n        token = self.symbols_[token] || token;\n      }\n\n      return token;\n    };\n\n    var symbol,\n        preErrorSymbol,\n        state,\n        action,\n        r,\n        yyval = {},\n        p,\n        len,\n        newState,\n        expected;\n\n    while (true) {\n      state = stack[stack.length - 1];\n\n      if (this.defaultActions[state]) {\n        action = this.defaultActions[state];\n      } else {\n        if (symbol === null || typeof symbol == 'undefined') {\n          symbol = lex();\n        }\n\n        action = table[state] && table[state][symbol];\n      }\n\n      if (typeof action === 'undefined' || !action.length || !action[0]) {\n        var errStr = '';\n        expected = [];\n\n        for (p in table[state]) {\n          if (this.terminals_[p] && p > TERROR) {\n            expected.push('\\'' + this.terminals_[p] + '\\'');\n          }\n        }\n\n        if (lexer.showPosition) {\n          errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n        } else {\n          errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n        }\n\n        this.parseError(errStr, {\n          text: lexer.match,\n          token: this.terminals_[symbol] || symbol,\n          line: lexer.yylineno,\n          loc: yyloc,\n          expected: expected\n        });\n      }\n\n      if (action[0] instanceof Array && action.length > 1) {\n        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n      }\n\n      switch (action[0]) {\n        case 1:\n          stack.push(symbol);\n          vstack.push(lexer.yytext);\n          lstack.push(lexer.yylloc);\n          stack.push(action[1]);\n          symbol = null;\n\n          if (!preErrorSymbol) {\n            yyleng = lexer.yyleng;\n            yytext = lexer.yytext;\n            yylineno = lexer.yylineno;\n            yyloc = lexer.yylloc;\n          } else {\n            symbol = preErrorSymbol;\n            preErrorSymbol = null;\n          }\n\n          break;\n\n        case 2:\n          len = this.productions_[action[1]][1];\n          yyval.$ = vstack[vstack.length - len];\n          yyval._$ = {\n            first_line: lstack[lstack.length - (len || 1)].first_line,\n            last_line: lstack[lstack.length - 1].last_line,\n            first_column: lstack[lstack.length - (len || 1)].first_column,\n            last_column: lstack[lstack.length - 1].last_column\n          };\n\n          if (ranges) {\n            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n          }\n\n          r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n          if (typeof r !== 'undefined') {\n            return r;\n          }\n\n          if (len) {\n            stack = stack.slice(0, -1 * len * 2);\n            vstack = vstack.slice(0, -1 * len);\n            lstack = lstack.slice(0, -1 * len);\n          }\n\n          stack.push(this.productions_[action[1]][0]);\n          vstack.push(yyval.$);\n          lstack.push(yyval._$);\n          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n          stack.push(newState);\n          break;\n\n        case 3:\n          return true;\n      }\n    }\n\n    return true;\n  }\n};\n/* generated by jison-lex 0.3.4 */\n\nvar lexer = function () {\n  var lexer = {\n    EOF: 1,\n    parseError: function parseError(str, hash) {\n      if (this.yy.parser) {\n        this.yy.parser.parseError(str, hash);\n      } else {\n        throw new Error(str);\n      }\n    },\n    // resets the lexer, sets new input\n    setInput: function setInput(input, yy) {\n      this.yy = yy || this.yy || {};\n      this._input = input;\n      this._more = this._backtrack = this.done = false;\n      this.yylineno = this.yyleng = 0;\n      this.yytext = this.matched = this.match = '';\n      this.conditionStack = ['INITIAL'];\n      this.yylloc = {\n        first_line: 1,\n        first_column: 0,\n        last_line: 1,\n        last_column: 0\n      };\n\n      if (this.options.ranges) {\n        this.yylloc.range = [0, 0];\n      }\n\n      this.offset = 0;\n      return this;\n    },\n    // consumes and returns one char from the input\n    input: function input() {\n      var ch = this._input[0];\n      this.yytext += ch;\n      this.yyleng++;\n      this.offset++;\n      this.match += ch;\n      this.matched += ch;\n      var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n\n      if (lines) {\n        this.yylineno++;\n        this.yylloc.last_line++;\n      } else {\n        this.yylloc.last_column++;\n      }\n\n      if (this.options.ranges) {\n        this.yylloc.range[1]++;\n      }\n\n      this._input = this._input.slice(1);\n      return ch;\n    },\n    // unshifts one char (or a string) into the input\n    unput: function unput(ch) {\n      var len = ch.length;\n      var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n      this._input = ch + this._input;\n      this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;\n\n      this.offset -= len;\n      var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n      this.match = this.match.substr(0, this.match.length - 1);\n      this.matched = this.matched.substr(0, this.matched.length - 1);\n\n      if (lines.length - 1) {\n        this.yylineno -= lines.length - 1;\n      }\n\n      var r = this.yylloc.range;\n      this.yylloc = {\n        first_line: this.yylloc.first_line,\n        last_line: this.yylineno + 1,\n        first_column: this.yylloc.first_column,\n        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n      };\n\n      if (this.options.ranges) {\n        this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n      }\n\n      this.yyleng = this.yytext.length;\n      return this;\n    },\n    // When called from action, caches matched text and appends it on next action\n    more: function more() {\n      this._more = true;\n      return this;\n    },\n    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n    reject: function reject() {\n      if (this.options.backtrack_lexer) {\n        this._backtrack = true;\n      } else {\n        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n          text: \"\",\n          token: null,\n          line: this.yylineno\n        });\n      }\n\n      return this;\n    },\n    // retain first n characters of the match\n    less: function less(n) {\n      this.unput(this.match.slice(n));\n    },\n    // displays already matched input, i.e. for error messages\n    pastInput: function pastInput() {\n      var past = this.matched.substr(0, this.matched.length - this.match.length);\n      return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n    // displays upcoming input, i.e. for error messages\n    upcomingInput: function upcomingInput() {\n      var next = this.match;\n\n      if (next.length < 20) {\n        next += this._input.substr(0, 20 - next.length);\n      }\n\n      return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n    // displays the character position where the lexing error occurred, i.e. for error messages\n    showPosition: function showPosition() {\n      var pre = this.pastInput();\n      var c = new Array(pre.length + 1).join(\"-\");\n      return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n    // test the lexed token: return FALSE when not a match, otherwise return token\n    test_match: function test_match(match, indexed_rule) {\n      var token, lines, backup;\n\n      if (this.options.backtrack_lexer) {\n        // save context\n        backup = {\n          yylineno: this.yylineno,\n          yylloc: {\n            first_line: this.yylloc.first_line,\n            last_line: this.last_line,\n            first_column: this.yylloc.first_column,\n            last_column: this.yylloc.last_column\n          },\n          yytext: this.yytext,\n          match: this.match,\n          matches: this.matches,\n          matched: this.matched,\n          yyleng: this.yyleng,\n          offset: this.offset,\n          _more: this._more,\n          _input: this._input,\n          yy: this.yy,\n          conditionStack: this.conditionStack.slice(0),\n          done: this.done\n        };\n\n        if (this.options.ranges) {\n          backup.yylloc.range = this.yylloc.range.slice(0);\n        }\n      }\n\n      lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n\n      if (lines) {\n        this.yylineno += lines.length;\n      }\n\n      this.yylloc = {\n        first_line: this.yylloc.last_line,\n        last_line: this.yylineno + 1,\n        first_column: this.yylloc.last_column,\n        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n      };\n      this.yytext += match[0];\n      this.match += match[0];\n      this.matches = match;\n      this.yyleng = this.yytext.length;\n\n      if (this.options.ranges) {\n        this.yylloc.range = [this.offset, this.offset += this.yyleng];\n      }\n\n      this._more = false;\n      this._backtrack = false;\n      this._input = this._input.slice(match[0].length);\n      this.matched += match[0];\n      token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n\n      if (this.done && this._input) {\n        this.done = false;\n      }\n\n      if (token) {\n        return token;\n      } else if (this._backtrack) {\n        // recover context\n        for (var k in backup) {\n          this[k] = backup[k];\n        }\n\n        return false; // rule action called reject() implying the next rule should be tested instead.\n      }\n\n      return false;\n    },\n    // return next match in input\n    next: function next() {\n      if (this.done) {\n        return this.EOF;\n      }\n\n      if (!this._input) {\n        this.done = true;\n      }\n\n      var token, match, tempMatch, index;\n\n      if (!this._more) {\n        this.yytext = '';\n        this.match = '';\n      }\n\n      var rules = this._currentRules();\n\n      for (var i = 0; i < rules.length; i++) {\n        tempMatch = this._input.match(this.rules[rules[i]]);\n\n        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n          match = tempMatch;\n          index = i;\n\n          if (this.options.backtrack_lexer) {\n            token = this.test_match(tempMatch, rules[i]);\n\n            if (token !== false) {\n              return token;\n            } else if (this._backtrack) {\n              match = false;\n              continue; // rule action called reject() implying a rule MISmatch.\n            } else {\n              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n              return false;\n            }\n          } else if (!this.options.flex) {\n            break;\n          }\n        }\n      }\n\n      if (match) {\n        token = this.test_match(match, rules[index]);\n\n        if (token !== false) {\n          return token;\n        } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n\n\n        return false;\n      }\n\n      if (this._input === \"\") {\n        return this.EOF;\n      } else {\n        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n          text: \"\",\n          token: null,\n          line: this.yylineno\n        });\n      }\n    },\n    // return next match that has a token\n    lex: function lex() {\n      var r = this.next();\n\n      if (r) {\n        return r;\n      } else {\n        return this.lex();\n      }\n    },\n    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n    begin: function begin(condition) {\n      this.conditionStack.push(condition);\n    },\n    // pop the previously active lexer condition state off the condition stack\n    popState: function popState() {\n      var n = this.conditionStack.length - 1;\n\n      if (n > 0) {\n        return this.conditionStack.pop();\n      } else {\n        return this.conditionStack[0];\n      }\n    },\n    // produce the lexer rule set which is active for the currently active lexer condition state\n    _currentRules: function _currentRules() {\n      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n      } else {\n        return this.conditions[\"INITIAL\"].rules;\n      }\n    },\n    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n    topState: function topState(n) {\n      n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n      if (n >= 0) {\n        return this.conditionStack[n];\n      } else {\n        return \"INITIAL\";\n      }\n    },\n    // alias for begin(condition)\n    pushState: function pushState(condition) {\n      this.begin(condition);\n    },\n    // return the number of states currently on the stack\n    stateStackSize: function stateStackSize() {\n      return this.conditionStack.length;\n    },\n    options: {},\n    performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n      switch ($avoiding_name_collisions) {\n        case 0:\n          // ignore\n          break;\n\n        case 1:\n          return 17;\n          break;\n\n        case 2:\n          return 18;\n          break;\n\n        case 3:\n          return 12;\n          break;\n\n        case 4:\n          return 19;\n          break;\n\n        case 5:\n          return 28;\n          break;\n\n        case 6:\n          return 29;\n          break;\n\n        case 7:\n          return 30;\n          break;\n\n        case 8:\n          return 31;\n          break;\n\n        case 9:\n          return 32;\n          break;\n\n        case 10:\n          return 14;\n          break;\n\n        case 11:\n          return 23;\n          break;\n\n        case 12:\n          return 22;\n          break;\n\n        case 13:\n          return 20;\n          break;\n\n        case 14:\n          return 21;\n          break;\n\n        case 15:\n          return 5;\n          break;\n\n        case 16:\n          return \"INVALID\";\n          break;\n      }\n    },\n    rules: [/^(?:\\s+)/, /^(?:\\()/, /^(?:\\))/, /^(?:-?[0-9]+(\\.[0-9]+)?([eE][\\-\\+]?[0-9]+)?)/, /^(?:POINT\\b)/, /^(?:LINESTRING\\b)/, /^(?:POLYGON\\b)/, /^(?:MULTIPOINT\\b)/, /^(?:MULTILINESTRING\\b)/, /^(?:MULTIPOLYGON\\b)/, /^(?:,)/, /^(?:EMPTY\\b)/, /^(?:M\\b)/, /^(?:Z\\b)/, /^(?:ZM\\b)/, /^(?:$)/, /^(?:.)/],\n    conditions: {\n      \"INITIAL\": {\n        \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n        \"inclusive\": true\n      }\n    }\n  };\n  return lexer;\n}();\n\nparser.lexer = lexer;\n\nfunction Parser() {\n  this.yy = {};\n}\n\nParser.prototype = parser;\nparser.Parser = Parser;\n\nfunction PointArray(point) {\n  this.data = [point];\n  this.type = 'PointArray';\n}\n\nPointArray.prototype.addPoint = function (point) {\n  if (point.type === 'PointArray') {\n    this.data = this.data.concat(point.data);\n  } else {\n    this.data.push(point);\n  }\n\n  return this;\n};\n\nPointArray.prototype.toJSON = function () {\n  return this.data;\n};\n\nfunction Ring(point) {\n  this.data = point;\n  this.type = 'Ring';\n}\n\nRing.prototype.toJSON = function () {\n  var data = [];\n\n  for (var i = 0; i < this.data.data.length; i++) {\n    data.push(this.data.data[i]);\n  }\n\n  return data;\n};\n\nfunction RingList(ring) {\n  this.data = [ring];\n  this.type = 'RingList';\n}\n\nRingList.prototype.addRing = function (ring) {\n  this.data.push(ring);\n  return this;\n};\n\nRingList.prototype.toJSON = function () {\n  var data = [];\n\n  for (var i = 0; i < this.data.length; i++) {\n    data.push(this.data[i].toJSON());\n  }\n\n  if (data.length === 1) {\n    return data;\n  } else {\n    return data;\n  }\n};\n\nfunction PolygonList(polygon) {\n  this.data = [polygon];\n  this.type = 'PolygonList';\n}\n\nPolygonList.prototype.addPolygon = function (polygon) {\n  this.data.push(polygon);\n  return this;\n};\n\nPolygonList.prototype.toJSON = function () {\n  var data = [];\n\n  for (var i = 0; i < this.data.length; i++) {\n    data = data.concat([this.data[i].toJSON()]);\n  }\n\n  return data;\n};\n/**\n * Converts a [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) geometry into a GeoJSON geometry.\n * @function\n * @param {string} WKT - The input WKT geometry.\n * @return {object} GeoJSON.\n *\n * ```js\n * import { wktToGeoJSON } from \"@terraformer/wkt\"\n *\n * wktToGeoJSON(\"POINT (-122.6764 45.5165)\");\n *\n * >> { \"type\": \"Point\", \"coordinates\": [ -122.6764, 45.5165 ] }\n * ```\n */\n\n\nvar wktToGeoJSON = function wktToGeoJSON(element) {\n  var res;\n\n  try {\n    res = parser.parse(element);\n  } catch (err) {\n    throw Error('Unable to parse: ' + err);\n  }\n\n  return res;\n};\n\nvar arrayToRing = function arrayToRing(arr) {\n  var parts = [];\n  var ret = '';\n\n  for (var i = 0; i < arr.length; i++) {\n    parts.push(arr[i].join(' '));\n  }\n\n  ret += '(' + parts.join(', ') + ')';\n  return ret;\n};\n\nvar pointToWKTPoint = function pointToWKTPoint(geojson) {\n  var ret = 'POINT ';\n\n  if (geojson.coordinates === undefined || geojson.coordinates.length === 0) {\n    ret += 'EMPTY';\n    return ret;\n  } else if (geojson.coordinates.length === 3) {\n    // 3d or time? default to 3d\n    if (geojson.properties && geojson.properties.m === true) {\n      ret += 'M ';\n    } else {\n      ret += 'Z ';\n    }\n  } else if (geojson.coordinates.length === 4) {\n    // 3d and time\n    ret += 'ZM ';\n  } // include coordinates\n\n\n  ret += '(' + geojson.coordinates.join(' ') + ')';\n  return ret;\n};\n\nvar lineStringToWKTLineString = function lineStringToWKTLineString(geojson) {\n  var ret = 'LINESTRING ';\n\n  if (geojson.coordinates === undefined || geojson.coordinates.length === 0 || geojson.coordinates[0].length === 0) {\n    ret += 'EMPTY';\n    return ret;\n  } else if (geojson.coordinates[0].length === 3) {\n    if (geojson.properties && geojson.properties.m === true) {\n      ret += 'M ';\n    } else {\n      ret += 'Z ';\n    }\n  } else if (geojson.coordinates[0].length === 4) {\n    ret += 'ZM ';\n  }\n\n  ret += arrayToRing(geojson.coordinates);\n  return ret;\n};\n\nvar polygonToWKTPolygon = function polygonToWKTPolygon(geojson) {\n  var ret = 'POLYGON ';\n\n  if (geojson.coordinates === undefined || geojson.coordinates.length === 0 || geojson.coordinates[0].length === 0) {\n    ret += 'EMPTY';\n    return ret;\n  } else if (geojson.coordinates[0][0].length === 3) {\n    if (geojson.properties && geojson.properties.m === true) {\n      ret += 'M ';\n    } else {\n      ret += 'Z ';\n    }\n  } else if (geojson.coordinates[0][0].length === 4) {\n    ret += 'ZM ';\n  }\n\n  ret += '(';\n  var parts = [];\n\n  for (var i = 0; i < geojson.coordinates.length; i++) {\n    parts.push(arrayToRing(geojson.coordinates[i]));\n  }\n\n  ret += parts.join(', ');\n  ret += ')';\n  return ret;\n};\n\nvar multiPointToWKTMultiPoint = function multiPointToWKTMultiPoint(geojson) {\n  var ret = 'MULTIPOINT ';\n\n  if (geojson.coordinates === undefined || geojson.coordinates.length === 0 || geojson.coordinates[0].length === 0) {\n    ret += 'EMPTY';\n    return ret;\n  } else if (geojson.coordinates[0].length === 3) {\n    if (geojson.properties && geojson.properties.m === true) {\n      ret += 'M ';\n    } else {\n      ret += 'Z ';\n    }\n  } else if (geojson.coordinates[0].length === 4) {\n    ret += 'ZM ';\n  }\n\n  ret += arrayToRing(geojson.coordinates);\n  return ret;\n};\n\nvar multiLineStringToWKTMultiLineString = function multiLineStringToWKTMultiLineString(geojson) {\n  var ret = 'MULTILINESTRING ';\n\n  if (geojson.coordinates === undefined || geojson.coordinates.length === 0 || geojson.coordinates[0].length === 0) {\n    ret += 'EMPTY';\n    return ret;\n  } else if (geojson.coordinates[0][0].length === 3) {\n    if (geojson.properties && geojson.properties.m === true) {\n      ret += 'M ';\n    } else {\n      ret += 'Z ';\n    }\n  } else if (geojson.coordinates[0][0].length === 4) {\n    ret += 'ZM ';\n  }\n\n  ret += '(';\n  var parts = [];\n\n  for (var i = 0; i < geojson.coordinates.length; i++) {\n    parts.push(arrayToRing(geojson.coordinates[i]));\n  }\n\n  ret += parts.join(', ');\n  ret += ')';\n  return ret;\n};\n\nvar multiPolygonToWKTMultiPolygon = function multiPolygonToWKTMultiPolygon(geojson) {\n  var ret = 'MULTIPOLYGON ';\n\n  if (geojson.coordinates === undefined || geojson.coordinates.length === 0 || geojson.coordinates[0].length === 0) {\n    ret += 'EMPTY';\n    return ret;\n  } else if (geojson.coordinates[0][0][0].length === 3) {\n    if (geojson.properties && geojson.properties.m === true) {\n      ret += 'M ';\n    } else {\n      ret += 'Z ';\n    }\n  } else if (geojson.coordinates[0][0][0].length === 4) {\n    ret += 'ZM ';\n  }\n\n  ret += '(';\n  var inner = [];\n\n  for (var c = 0; c < geojson.coordinates.length; c++) {\n    var it = '(';\n    var parts = [];\n\n    for (var i = 0; i < geojson.coordinates[c].length; i++) {\n      parts.push(arrayToRing(geojson.coordinates[c][i]));\n    }\n\n    it += parts.join(', ');\n    it += ')';\n    inner.push(it);\n  }\n\n  ret += inner.join(', ');\n  ret += ')';\n  return ret;\n};\n/**\n * Converts a GeoJSON geometry or GeometryCollection into a [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) string.\n * @function\n * @param {object} GeoJSON - The input GeoJSON geometry or GeometryCollection.\n * @return {string} WKT.\n * ```js\n * import { geojsonToWKT } from \"@terraformer/wkt\"\n *\n * const geojsonPoint = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [-122.6764, 45.5165]\n * }\n *\n * geojsonToWKT(geojsonPoint)\n *\n * >> \"POINT (-122.6764 45.5165)\"\n * ```\n */\n\n\nvar geojsonToWKT = function geojsonToWKT(geojson) {\n  switch (geojson.type) {\n    case 'Point':\n      return pointToWKTPoint(geojson);\n\n    case 'LineString':\n      return lineStringToWKTLineString(geojson);\n\n    case 'Polygon':\n      return polygonToWKTPolygon(geojson);\n\n    case 'MultiPoint':\n      return multiPointToWKTMultiPoint(geojson);\n\n    case 'MultiLineString':\n      return multiLineStringToWKTMultiLineString(geojson);\n\n    case 'MultiPolygon':\n      return multiPolygonToWKTMultiPolygon(geojson);\n\n    case 'GeometryCollection':\n      var ret = 'GEOMETRYCOLLECTION';\n      var parts = [];\n\n      for (var i = 0; i < geojson.geometries.length; i++) {\n        parts.push(geojsonToWKT(geojson.geometries[i]));\n      }\n\n      return ret + '(' + parts.join(', ') + ')';\n\n    default:\n      throw Error('Unknown Type: ' + geojson.type);\n  }\n};\n\nexport { Parser, geojsonToWKT, parser, wktToGeoJSON };","map":null,"metadata":{},"sourceType":"module"}